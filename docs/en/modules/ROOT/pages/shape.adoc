= Choosing collision shapes
:Project: Libbulletjme
:item: &rarr;
:page-pagination:
:url-api: https://stephengold.github.io/Libbulletjme/javadoc/master/com/jme3/bullet
:url-enwiki: https://en.wikipedia.org/wiki
:url-shape: https://stephengold.github.io/Libbulletjme/javadoc/master/com/jme3/bullet/collision/shapes
:url-tutorial: https://github.com/stephengold/LbjExamples/blob/master/apps/src/main/java/com/github/stephengold/lbjexamples/apps

A _collision shape_
describes the shape and size of a collision object such as a rigid body.

== The 16 shape classes

The examples so far have all used spheres, cubes, and/or cylinders.
However, those are only 3 of the 16 subclasses of
{url-shape}/CollisionShape.html[`CollisionShape`].

The {url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`]
class is especially important because
it enables any number of _child shapes_
to be combined into a single _compound shape_.

The subclasses are summarized here, in lexicographic order,
with illustrations and lists of key properties (explained below):

[cols="2*",grid="none"]
|===

|1. {url-shape}/Box2dShape.html[`Box2dShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable +
{item} symmetric
|image:box2d.png[height=160]

|2. {url-shape}/BoxCollisionShape.html[`BoxCollisionShape`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable +
{item} symmetric
|image:box.png[height=160]

|3. {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only +
{item} symmetric
|image:capsule.png[height=160]

|4. {url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`]

{item} neither concave nor convex +
{item} positive margin +
{item} precise if-and-only-if all of its children are precise +
{item} scalable to the extent that all of its children are scalable
|image:compound.png[height=160]

|5. {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} uniform scaling only +
{item} symmetric
|image:cone.png[height=160]

|6. {url-shape}/Convex2dShape.html[`Convex2dShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} scalable to the extent that its base shape is scalable
|image:convex2d.png[height=160]

|7. {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} limited scalability +
{item} symmetric
|image:cylinder.png[height=160]

|8. {url-shape}/EmptyShape.html[`EmptyShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother? +
{item} symmetric
|(no image)

|9. {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:gimpact.png[height=160]

|10. {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:heightfield.png[height=160]

|11. {url-shape}/HullCollisionShape.html[`HullCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} fully scalable
|image:hull.png[height=160]

|12. {url-shape}/MeshCollisionShape.html[`MeshCollisionShape`]

{item} concave +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:mesh.png[height=160]

|13. {url-shape}/MultiSphere.html[`MultiSphere`]

{item} convex +
{item} positive margin +
{item} precise +
{item} fully scalable
|image:multiSphere.png[height=160]

|14. {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`]

{item} concave and infinite +
{item} positive margin +
{item} precise +
{item} fully scalable, but why bother? +
{item} symmetric
|image:plane.png[height=160]

|15. {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]

{item} convex +
{item} positive margin +
{item} imprecise +
{item} not scalable
|image:simplex.png[height=160]

|16. {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]

{item} convex +
{item} zero margin +
{item} precise +
{item} uniform scaling only +
{item} symmetric
|image:sphere.png[height=160]

|===

[NOTE]
====
Due to limitations of Bullet, collisions between `HeightfieldCollisionShape`,
`MeshCollisionShape`, and `PlaneCollisionShape` objects are never detected.
However, such objects *will* collide with objects having compound, convex,
or GImpact shapes.
====

== Convex versus concave

The _convex_ collision-shape classes are those
that guarantee the _convex property_:
for any 2 locations inside a shape,
the line segment connecting those locations lies entirely inside the shape.

Here are 2 equivalent ways to test whether a shape belongs to a convex class:

[source,java]
----
boolean convexClass = (shape instanceof ConvexShape);
boolean isConvex = shape.isConvex();
assert convexClass == isConvex;
----

NOTE: In this context, "convex" is a property of classes, not instances.
While specific *instances* of non-convex classes have the convex property,
those classes don't guarantee it for *all* instances.

_Concave_ is essentially the opposite of convex, except that compound shapes
are regarded as neither convex nor concave.
No shape is both convex *and* concave.
To test whether a shape belongs to a concave class, use `shape.isConcave()`.

== Margin

All collision-shape subtypes except
{url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`]
and
{url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]
incorporate a _margin_, a narrow zone near the surface of the shape.
(The word _margin_ refers to both the zone and its thickness.)
According to
https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf[the Bullet User Manual],
the purpose of margin is
"to improve performance and reliability of the collision detection."

For all shapes with margin, the default thickness is 0.04 physics-space units.

NOTE: While methods are provided to alter margins (and the default margin),
doing so is not recommended.

== Precise versus imprecise

A _precise shape_ is a collision shape whose _effective shape_
(observed in collisions, contact tests, ray tests, and sweep tests)
is unaffected by margin.

While most collision-shape subtypes are precise, 5 of them are not.
For 4 of them, margin simply expands their effective shapes:

. {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`]
. {url-shape}/Convex2dShape.html[`Convex2dShape`]
. {url-shape}/HullCollisionShape.html[`HullCollisionShape`]
. {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]

Margin also distorts a
{url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`],
but its effect there is more complicated.

Here are illustrations of 4 otherwise identical simplex shapes
with different margins:

[cols="2*",grid="none"]
|===
|image:margin1.png[height=160]
|image:margin4.png[height=160]
|image:margin5.png[height=160]
|image:margin6.png[height=160]
|===

Since margin is defined in physics-space units,
its effects are most noticeable for small shapes.

When using imprecise shapes, you may compensate for margin
by shrinking the shape's dimensions (for a cone or cylinder shape)
or by moving its defining vertices inward (for a simplex or hull shape).

Another possible workaround would be to scale the physics space
so as to make the effects of margin less obvious.

== Suitability for dynamic bodies

Not all collision shapes are suitable for dynamic rigid bodies.

For instance,
collision detection is unreliable between zero-thickness shapes such as:

* {url-shape}/Box2dShape.html[`Box2dShape`],
* {url-shape}/Convex2dShape.html[`Convex2dShape`],
* {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`],
* {url-shape}/HullCollisionShape.html[`HullCollisionShape`]
  with 1-to-3 vertices,
* {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`], and
* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]
  with 1-to-3 vertices.

Furthermore, the following shape classes are suitable *only*
for kinematic or static objects because
the simulator cannot determine their mass distributions:

* {url-shape}/EmptyShape.html[`EmptyShape`],
* {url-shape}/HeightfieldCollisionShape.html[`HeightfieldCollisionShape`],
* {url-shape}/MeshCollisionShape.html[`MeshCollisionShape`], and
* {url-shape}/PlaneCollisionShape.html[`PlaneCollisionShape`].

The safest shapes for dynamic rigid bodies are the 5 _primitives_ listed below.
All have at least one {url-enwiki}/Rotational_symmetry[axis of symmetry],
and their centers and axes are well-known:

. {url-shape}/BoxCollisionShape.html[`BoxCollisionShape`],
. {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`],
. {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`],
. {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`], and
. {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`].

Many asymmetric shapes are also suitable for dynamic rigid bodies.
With such shapes, however, care should be taken to ensure the plausibility of
the center of mass and principal axes.
At the very least,
the shape's center should be located well inside its convex hull.

{url-tutorial}/HelloMadMallet.java[HelloMadMallet]
demonstrates the effect of an implausibly centered shape.
Things to notice while running the app:

. A dynamic rigid body, shaped like a mallet,
  falls under the influence of gravity.
. Unlike a real mallet, the body's center of mass (visualized by 3 arrows)
  is located at the end of its handle.
. After landing, the mallet tends to stand erect.
  Although this orientation seems unnatural, it is the precisely the one
  that minimizes the mallet's
  {url-enwiki}/Gravitational_potential[gravitational potential].

The following classes
can be used to generate asymmetric shapes for rigid bodies:

* {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`],
* {url-shape}/HullCollisionShape.html[`HullCollisionShape`]
  with 4 or more vertices,
* {url-shape}/MultiSphere.html[`MultiSphere`],
* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]
  with 4 vertices, and
* {url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`]
  with suitable children.

In the case of a
{url-shape}/CompoundCollisionShape.html[`CompoundCollisionShape`],
the `principalAxes()` and `correctAxes()` methods
may be used to adjust its center and axes for a specific mass distribution.

{url-tutorial}/HelloMassDistribution.java[HelloMassDistribution]
demonstrates the use of `principalAxes()` and `correctAxes()`.
Things to notice while running the app:

. This time, the mallet's center of mass (visualized by 3 arrows)
  lies much closer to the head, in a very plausible location.
. After landing, the mallet comes to rest on its side,
  which is a natural orientation for a mallet.

NOTE: The `principalAxes()` method relies on each child having an accurate
center, axes, and moment of inertia.

== Scaling

Some applications require collision shapes that are _scalable_
(can be dynamically shrunk or enlarged).
However, not all collision shapes can scale arbitrarily.
In particular:

* {url-shape}/SimplexCollisionShape.html[`SimplexCollisionShape`]
  doesn't support scaling;
  the only allowed scale is (1,1,1).
* {url-shape}/CapsuleCollisionShape.html[`CapsuleCollisionShape`],
  {url-shape}/ConeCollisionShape.html[`ConeCollisionShape`], and
  {url-shape}/SphereCollisionShape.html[`SphereCollisionShape`]
  support only uniform scaling, where all axes have the same scale factor,
  such as (0.2, 0.2, 0.2) or (9,9,9).
* {url-shape}/CylinderCollisionShape.html[`CylinderCollisionShape`]
  allows the height and base to scale independently,
  but the scale factors of both base axes must be equal.
  In other words, the cross section must remain circular.
  So (9,9,9) would be allowed for any cylinder,
  but (9,1,1) would be allowed only for cylinders
  where the local X axis is the height axis.

You can test at runtime whether a particular scaling
is applicable to particular shape:

[source,java]
----
if (shape.canScale(newScale)) {
    shape.setScale(newScale);
}
----

== Choosing a shape

For efficient simulation, the general rule is:
"Use the simplest shape that yields the desired *behavior*."
Focusing on behavior (rather than appearance)
helps you avoid simulating details that don't matter.
For instance:

* A character's hair should probably be omitted from their collision shape.
* Any small object that only encounters large, flat surfaces
  can probably be approximated by a convex hull.
* As long as a container remains sealed,
  its collision shape need not be hollow.

Because most 3-D models are composed of triangle meshes,
beginners are often tempted to use mesh-based shapes
(such as {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`])
for everything.
However, since mesh-based collision detection is CPU-intensive,
simpler shapes are often a better choice,
even when they don't closely match the model's shape.
In particular, capsule shapes are often used for humanoid models.

The following pseudo-code algorithm may be helpful:

----
if (the object doesn't move and isn't involved in collisions) {
    use an EmptyShape or don't add the object to the space
} else if (the object doesn't move
           and its shape can be approximated by an infinite plane) {
    use a PlaneCollisionShape
} else if (the object doesn't move
          and its shape can be approximated by point, line segment, or triangle) {
    use a SimplexCollisionShape
} else if (the object doesn't move
           and its shape can be approximated by rectangle) {
    use a Box2dShape
} else if (the object doesn't move
           and its shape can be approximated by 2-D convex polygon) {
    use a Convex2dShape
} else if (its shape can be approximated by a tetrahedron) {
    use a SimplexCollisionShape
} else if (its shape can be approximated by a centered sphere) {
    use a SphereCollisionShape
} else if (its shape can be approximated by a centered rectangular solid) {
    use a BoxCollisionShape
} else if (its shape can be approximated by a centered capsule) {
    use a CapsuleCollisionShape
} else if (its shape can be approximated by a centered cylinder) {
    use a CylinderCollisionShape
} else if (its shape can be approximated by a centered cone) {
    use a ConeCollisionShape
} else if (its shape can be approximated by an ellipsoid
           or an eccentric sphere
           or an eccentric capsule
           or the convex hull of multiple spheres) {
    use a MultiSphere
} else if (its shape can be approximated by an eccentric primitive
           or a combination of convex primitives) {
    use a CompoundCollisionShape
} else if (the object does not move) {
    if (it is a heightfield) {
        use a HeightfieldCollisionShape
    } else {
        use a MeshCollisionShape
    }
} else { // if the object moves
    if (its shape can be approximated by a convex hull) {
        use a HullCollisionShape
    } else if (its shape can be decomposed into convex hulls) {
        use a compound of hull shapes
    } else {
        use a GImpactCollisionShape
    }
}
----

(Pseudocode adapted from the flowchart on page 13 of
https://github.com/bulletphysics/bullet3/blob/master/docs/Bullet_User_Manual.pdf[the Bullet User Manual].)

NOTE: {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`]
should be your last resort!

Faced with the task of simulating a non-convex rigid body
(such as a cross or ring),
it's best to decompose it into convex shapes that,
when recombined, will approximate the desired behavior.

There are various approaches,
depending how much the developer knows about the object's shape.
If the model's mesh is generated procedurally, it may be possible
to decompose it during the generation process.
Or if the object is modeled in Blender,
it may be practical to manually decompose it there
into meshes that are convex or nearly so.

== Automated decomposition

For situations where manual decomposition is impractical,
{Project} incorporates Khaled Mamou's
https://github.com/kmammou/v-hacd[Volumetric-Hierarchical Approximate Convex Decomposition (V-HACD) algorithm].
V-HACD makes it easy to decompose a 3-D model into a
compound of hull shapes:

[source,java]
----
VHACDParameters parms = new VHACDParameters();
CollisionShape shape
        = CollisionShapeFactory.createVhacdShape(modelRoot, parms, null);
----

The V-HACD algorithm is costly to run, but for many applications it can
be run in advance and the output stored until needed.
During simulation, the resulting shape will usually be much far efficient
than a GImpact shape.

== Summary

* {Project} provides 16 types of collision shapes,
  ranging from the trivial {url-shape}/EmptyShape.html[`EmptyShape`]
  to the costly {url-shape}/GImpactCollisionShape.html[`GImpactCollisionShape`].
* Collision-shape instances classified as "concave"
  may still exhibit the convex property.
* Most collision shapes incorporate a margin.
* Margin distorts the effective shape of imprecise collision shapes.
* Most collision shapes can be scaled, but not all can be scaled non-uniformly.
* Not all collision shapes are suitable for dynamic rigid bodies.
* Before applying an asymmetric shape to a dynamic rigid body,
  make sure its center and principal axes are plausible.
* Use the simplest shape that yields the desired behavior.
* To speed up simulation of objects with non-convex shapes,
  decompose them into convex ones,
  either during model construction or using V-HACD.
